<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenMoCo AVR Libraries: OMMenuMgr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenMoCo AVR Libraries
   </div>
   <div id="projectbrief">Motion Control and MoCoBus Libraries for the AVR Platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_m_menu_mgr.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OMMenuMgr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.  
 <a href="class_o_m_menu_mgr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_m_menu_mgr_8h_source.html">OMMenuMgr.h</a>&gt;</code></p>

<p><a href="class_o_m_menu_mgr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c9f9a0226f69fa23b9efb450642bc16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a7c9f9a0226f69fa23b9efb450642bc16">OMMenuMgr</a> (<a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> *c_first, uint8_t c_type=MENU_ANALOG)</td></tr>
<tr class="memitem:a189699b2a1eed8b4083496f75eab51d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a189699b2a1eed8b4083496f75eab51d7">setAnalogButtonPin</a> (uint8_t p_pin, const int p_values[5][2], int p_thresh)</td></tr>
<tr class="memitem:a16e9d84692b4abee1c7af7a07ce6c48a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a16e9d84692b4abee1c7af7a07ce6c48a">setDigitalButtonPins</a> (const int p_pins[5][2])</td></tr>
<tr class="memitem:ade4543555c00c157c4018b76da05b9b3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a> ()</td></tr>
<tr class="memitem:a34a5df068f1cb8b15e3e39accfc71b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a> (bool p_en)</td></tr>
<tr class="memitem:a9bf7bbb045003f05fbb63d6418fb19a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a9bf7bbb045003f05fbb63d6418fb19a5">enable</a> ()</td></tr>
<tr class="memitem:a1f4ce5a7db0116134f911b8f29dc1603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a1f4ce5a7db0116134f911b8f29dc1603">setDrawHandler</a> (void(*p_func)(char *, int, int, int))</td></tr>
<tr class="memitem:a9e33a3a3eb68895e28225d66678280da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a9e33a3a3eb68895e28225d66678280da">setExitHandler</a> (void(*p_func)())</td></tr>
<tr class="memitem:a1673397a534ccd405c4dcebbf6443b7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a1673397a534ccd405c4dcebbf6443b7f">setRoot</a> (<a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> *p_root)</td></tr>
<tr class="memitem:a60f1026509c85417954a6c578d64e1ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#a60f1026509c85417954a6c578d64e1ba">shown</a> ()</td></tr>
<tr class="memitem:ad05b6293f26577d9aa161f5e4b50ccda"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_m_menu_mgr.html#ad05b6293f26577d9aa161f5e4b50ccda">holdModifier</a> ()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows. </p>
<pre class="fragment">OpenMoCo Menu Manager Class
</pre><p>Designed to make it easy to implement menu systems, the Menu Manager requires the developer to do little more than specify the structure of the menu, and how to draw on the display.</p>
<p>Key features:<br/>
 </p>
<ul>
<li>
Menu structures automatically and easily stored in program memory instead of SRAM </li>
<li>
Automatic handling of either analog or digital button inputs </li>
<li>
Automatic management of user inputs for numeric and select list types <ul>
<li>
In-place editing with ability for user to abort </li>
<li>
Write-back on user save to original variables </li>
<li>
Specify lists of display values for users to select between </li>
<li>
Control over user input precision in floats, and more </li>
</ul>
</li>
<li>
Ability to trigger code actions from menu items </li>
<li>
One-method polling automatically handles and executes menu as-needed </li>
<li>
Streamlined setup for complex and even recursive menus </li>
<li>
Support for any width screen </li>
<li>
Reduced memory footprint </li>
<li>
No fixed limitations on menu depths, have as many sub-menus as you require </li>
<li>
Flexible drawing methodology allows the user of any character-based (or even graphic) display </li>
</ul>
<dl class="section author"><dt>Author:</dt><dd>C. A. Church Dynamic Perception LLC</dd></dl>
<p>See <a href="http://www.dynamicperception.com">http://www.dynamicperception.com</a> for more information</p>
<p>(c) 2008-2012 C.A. Church / Dynamic Perception LLC</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<h1><a class="anchor" id="menuoverview"></a>
Overview</h1>
<p>The Menu Manager displays a character-based menu when triggered by the user. Five user inputs are used (although only four are required): Enter, Up, Down, Back, and Forward. Forward is optional. These inputs may either be buttons tied to digital pins, or up to five buttons tied to a single analog pin using a series of resistors to present different analog values when a button is pressed.</p>
<p>The menu is triggered by hitting the Enter key by the user when the menu is enabled. When it is displayed, the user is presented with all available options at the current menu level, one per row, with a cursor indicating the currently selected item. The up and down keys scroll the list through all available items at the current menu level. If the user presses enter, or forward on the current item, the item will be presented as either a value edit, a new menu, or an action will be executed as defined by the user based on the type of the menu entry. The back button will cancel out of the current input, go back one menu level, or exit the menu entirely if the user is at the root menu level.</p>
<p>When a value is being edited, the user may adjust the value within the range specified by the developer non-destructively using the up and down buttons. The user may cancel the edit of the value by using the back button, or may save the value using either of enter or forward. When the user saves the value, it is written directly to the variable specified by the developer. All numeric types are supported; individual bit flags, and special select lists are supported as well. For select lists, the user is presented with strings defined by the developer for the numeric values stored in the target variable, providing the ability to give the user a more complete and obvious solution.</p>
<p>Menu items may also be sub-menus. You can even re-use the same sub-menus under different menus with minimal impact to flash size and SRAM usage, letting you use the same menus under different contexts.</p>
<p>Menu items may be actions - you may wish to draw special screens and allow for use-case driven inputs. In this manner, you can trigger callbacks when menu items are triggered and disable the menu easily while interacting with the user, and then seamlessly place the user back into the menu where they left off when they are done.</p>
<p>Finally, the Menu Manager can be used to easily poll the user inputs without drawing the menu as needed by the developer.</p>
<h1><a class="anchor" id="menuitembasic"></a>
The Basics of Menu Items</h1>
<p>To create menu items, you'll need to specify their contents and create them using special datatypes which will keep them in program memory until needed. The basic item is defined via the MENU_ITEM data type, and specifies the label to give to the item, the type of item it is, the length (for certain types), and the target of the item. For example:</p>
<div class="fragment"><div class="line">                <span class="comment">//        LABEL           TYPE        LENGTH    TARGET</span></div>
<div class="line"> MENU_ITEM item_foo  = { {<span class="stringliteral">&quot;Foo Edit&quot;</span>},    ITEM_VALUE,  0,        MENU_TARGET(&amp;value_foo) };</div>
</div><!-- fragment --><p>There are three cores types of items: </p>
<ul>
<li>
ITEM_VALUE <ul>
<li>
A value to be edited, which will either be a numeric type or a select list </li>
</ul>
</li>
<li>
ITEM_ACTION <ul>
<li>
An action to be executed when the user hits enter or forward on the item </li>
</ul>
</li>
<li>
ITEM_MENU <ul>
<li>
A sub-menu to be displayed when the user hits enter or forward on the item </li>
</ul>
</li>
</ul>
<p>To create a value item, we must also create a special variables which tells the menu system how to process the item. This special variable will be constructed again from a new type, with several parameters:</p>
<div class="fragment"><div class="line"> byte foo = 0;</div>
<div class="line"> </div>
<div class="line">                 <span class="comment">//       Data Type        Max    Min    Target</span></div>
<div class="line"> MENU_VALUE value_foo = { TYPE_BYTE,       100,   0,     MENU_TARGET(&amp;foo) };</div>
<div class="line"> </div>
<div class="line">                 <span class="comment">//        LABEL           TYPE        LENGTH    TARGET</span></div>
<div class="line"> MENU_ITEM item_foo  = { {<span class="stringliteral">&quot;Foo Edit&quot;</span>},    ITEM_VALUE,  0,        MENU_TARGET(&amp;value_foo) };</div>
</div><!-- fragment --><p>Here, we see that we can specify the type of data the item points to, a maximum value, a minimum value, and the target variable (by address) to be edited. Minimum and Maximum values are limited to the range of a signed long, no matter the data type, and are not used for select lists.</p>
<p>The following Data Type values are allowed:</p>
<ul>
<li>
TYPE_BYTE </li>
<li>
TYPE_INT </li>
<li>
TYPE_UINT </li>
<li>
TYPE_LONG </li>
<li>
TYPE_ULONG </li>
<li>
TYPE_FLOAT <ul>
<li>
Whole integer changes, zero decimal precision per change </li>
</ul>
</li>
<li>
TYPE_FLOAT_10 <ul>
<li>
Change by tenths </li>
</ul>
</li>
<li>
TYPE_FLOAT_100 <ul>
<li>
Change by hundredths </li>
</ul>
</li>
<li>
TYPE_FLOAT_1000 <ul>
<li>
Change by thousandths </li>
</ul>
</li>
<li>
TYPE_SELECT </li>
<li>
TYPE_BFLAG </li>
</ul>
<h1><a class="anchor" id="menulists"></a>
The Basics of Creating Menus</h1>
<p>Of course, items on their own are of little use - we wouldn't typically go through all of this work to just have a single input! To create a menu, we need to create a list of items in that menu, and then create the item which represents the menu. For this, again, we have a special data type that allows us to easily create them and store in program space:</p>
<div class="fragment"><div class="line"> MENU_LIST root_list[] = { &amp;item_foo, &amp;item_bar };</div>
<div class="line"> </div>
<div class="line"> MENU_ITEM menu_root = { {<span class="stringliteral">&quot;Root Menu&quot;</span>},  ITEM_MENU,  MENU_SIZE(root_list),  MENU_TARGET(&amp;root_list) };</div>
</div><!-- fragment --><p>We may, of course, create multiple lists, use the same list in multiple items, and use the same items in multiple lists.</p>
<h1><a class="anchor" id="menuselect"></a>
The Basics of Creating Select Lists</h1>
<p>Creating a select list is a little more complex than a normal item value. Since we're displaying the user a list of strings, and mapping them back to numeric values, we need to create this mapping.</p>
<p>To do so, we need to create the items that will appear in lists, and the lists which use them:</p>
<div class="fragment"><div class="line"> MENU_SELECT_ITEM  sel_ign = { 2, {<span class="stringliteral">&quot;Ignore&quot;</span>} };</div>
<div class="line"> MENU_SELECT_ITEM  sel_on  = { 1, {<span class="stringliteral">&quot;On&quot;</span>} };</div>
<div class="line"> MENU_SELECT_ITEM  sel_off = { 0, {<span class="stringliteral">&quot;Off&quot;</span>} };</div>
<div class="line"> </div>
<div class="line"> MENU_SELECT_LIST  state_list[] = { &amp;sel_ign, &amp;sel_on, &amp;sel_off };</div>
</div><!-- fragment --><p>Note here, for each item we specify the numeric value associated with the string, and the string to display to the user. We can use these select items in any select list, but it is important to note that you should not duplicate a numeric value in one list.</p>
<p>The numeric values are specified as a byte type, and are limited to 0-255.</p>
<p>Finally, to create the target for a menu item to use this select list, we must create a special variable that specifies how to handle the select, where to store the target value, the length of the list, and the list to use:</p>
<div class="fragment"><div class="line"> byte myVar = 0;</div>
<div class="line"> </div>
<div class="line">                           <span class="comment">// TARGET VAR        LENGTH                          TARGET SELECT LIST</span></div>
<div class="line"> MENU_SELECT state_select = { &amp;myVar,           MENU_SELECT_SIZE(state_list),   MENU_TARGET(&amp;state_list) };</div>
<div class="line"> </div>
<div class="line"> MENU_VALUE  value_sel = { TYPE_SELECT, 0, 0, MENU_TARGET(&amp;state_select) };</div>
<div class="line"> MENU_ITEM   item_sel  = { {<span class="stringliteral">&quot;Select It&quot;</span>}, ITEM_VALUE, 0, MENU_TARGET(&amp;value_sel) };</div>
</div><!-- fragment --><h1><a class="anchor" id="menubitflag"></a>
The Basics of Creating Bit Flag Inputs</h1>
<p>A bit flag input allows you to change only one bit in a target variable, for example, in the case where you want to store up to 8 on/off flags in a single byte of data to preserve RAM. The Menu Manager supports doing this by creating a special target for the MENU_VALUE you're creating:</p>
<div class="fragment"><div class="line"> byte theseFlags = 0;</div>
<div class="line"> </div>
<div class="line"> MENU_FLAG    my_flag    = { 3, &amp;theseFlags };</div>
<div class="line"> MENU_VALUE   my_value   = { TYPE_BFLAG, 0, 0, MENU_TARGET(&amp;my_flag) };</div>
<div class="line"> MENU_ITEM    my_item    = { {<span class="stringliteral">&quot;Flag Edit&quot;</span>}, ITEM_VALUE, 0, MENU_TARGET(&amp;my_value) };</div>
</div><!-- fragment --><p>We'll note that the new MENU_FLAG type has two parts: the bit position, and the address of the byte containing the bit. The bit position is from the right and is of the range 0-7, so this item would modify the bit marked with 'x' in the following pattern: B1111x111</p>
<p>In this example, when the user interacts with the "Flag Edit" menu item, the user will be displayed the OM_MENU_FLAG_ON and OM_MENU_FLAG_OFF strings based on the value of bit 3 in the 'theseFlags' variable. When saved by the user, the correct bit value will be written back to bit 3 in 'theseFlags'.</p>
<p>If you want to change the strings used for On and Off, see the <a class="el" href="class_o_m_menu_mgr.html#menuparam">Setting Control Parameters</a> section below.</p>
<h1><a class="anchor" id="menuaction"></a>
The Basics of Creating Actions</h1>
<p>An action is a function that will be called when a user presses enter or forward on that item. This can be used to display special screens, or call some other behavior more complex than just setting a parameter.</p>
<p>All functions being called by actions must take no parameters, and return void. When an action is called, your callback handler is called. If the menu is still enabled when your callback handler exits, the menu will be re-drawn where it was when the action was initiated, otherwise the menu will not be displayed again until the menu is re-enabled and the <a class="el" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput()</a> method is called again. (For more info on disabling the menu, and polling inputs, see the <a class="el" href="class_o_m_menu_mgr.html#menupolling">Polling the Menu</a> section below.)</p>
<p>For example, we can create a special screen that is drawn when an action is triggered, which waits until the user presses a button before returning to the menu:</p>
<div class="fragment"><div class="line"> MENU_ITEM item_testme   = { {<span class="stringliteral">&quot;Test Action&quot;</span>},  ITEM_ACTION, 0,        MENU_TARGET(uiQwkScreen) };</div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> uiQwkScreen() {</div>
<div class="line">    lcd.clear();</div>
<div class="line">    Menu.enable(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Action!&quot;</span>);</div>
<div class="line">    lcd.setCursor(0, 1);</div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Enter 2 return&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>( Menu.checkInput() != BUTTON_SELECT ) {</div>
<div class="line">        ; <span class="comment">// wait!</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Menu.enable(<span class="keyword">true</span>);</div>
<div class="line">    lcd.clear();</div>
<div class="line"> }</div>
</div><!-- fragment --><h1><a class="anchor" id="menuinit"></a>
Initializing the Menu</h1>
<p>After we have created all of our menu items, lists, selects, and so forth, we need to initialize the <a class="el" href="class_o_m_menu_mgr.html" title="The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.">OMMenuMgr</a> object with a root item. This root item will be the starting point when the user triggers the menu, and should be an ITEM_MENU in most cases.</p>
<p>Additionally, we need to specify whether our input is analog (MENU_ANALOG, default), or digital (MENU_DIGITAL).</p>
<div class="fragment"><div class="line"> <a class="code" href="class_o_m_menu_mgr.html" title="The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.">OMMenuMgr</a> Menu = <a class="code" href="class_o_m_menu_mgr.html#a7c9f9a0226f69fa23b9efb450642bc16">OMMenuMgr</a>(&amp;menu_root, MENU_ANALOG);</div>
</div><!-- fragment --><p>Note that we always pass the root item by address, and not by value! You can always change the root item later, using the <a class="el" href="class_o_m_menu_mgr.html#a1673397a534ccd405c4dcebbf6443b7f">setRoot()</a> method.</p>
<h1><a class="anchor" id="menuinput"></a>
User Input</h1>
<p>After we have created our menu structure, we must specify how to handle user input. To do this, we must tell the Menu Manager how to read our buttons.</p>
<p>In both analog and digital cases, we must create a two-dimensional list of how to read buttons, and their meanings. This list will always have 5 lists of 2 elements. The format is:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">int</span> map = { </div>
<div class="line">             { button 1 read, button 1 definition },</div>
<div class="line">             { button 2 read, button 2 definition },</div>
<div class="line">            ...</div>
<div class="line">           };</div>
</div><!-- fragment --><p>The button definition is always one of the following:</p>
<p>BUTTON_FORWARD, BUTTON_BACK, BUTTON_INCREASE, BUTTON_DECREASE, BUTTON_SELECT</p>
<p>The how to read button instruction will differ based on whether you are doing analog or digital input. For digital inputs, the first element will be the Arduino digital pin # of the button, and for analog inputs, the first element will be analogRead() value associated with the button.</p>
<p>For digital input, we simply need to pass this array to the <a class="el" href="class_o_m_menu_mgr.html#a16e9d84692b4abee1c7af7a07ce6c48a">setDigitalButtonPins()</a> method. Also note, that for digital inputs the input pins will be pulled HIGH internally and you are expected to swing them to LOW when pressed.</p>
<p>For analog input, we must also specify the pin to read the value from, and the threshold for reading the values. The threshold is very important, as analog inputs are rarely exact; this threshold is the variance that will be applied to each value during comparison. These values and the button definition array are sent to the <a class="el" href="class_o_m_menu_mgr.html#a189699b2a1eed8b4083496f75eab51d7">setAnalogButtonPin()</a> method.</p>
<p>The following is a complete example of initializing an analog input:</p>
<div class="fragment"><div class="line"> <span class="comment">// which input is our button (use the digital pin#, not the analog pin #!)</span></div>
<div class="line"> <span class="keyword">const</span> byte BUT_PIN = 14;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// analog button read values</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUTSEL_VAL  = 70;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUTFWD_VAL  = 250;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUTREV_VAL  = 450;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUTDEC_VAL  = 655;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUTINC_VAL  = 830;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> byte BUT_THRESH  = 60;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// mapping of analog button values for menu</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> BUT_MAP[5][2] = {</div>
<div class="line">                                {BUTSEL_VAL, BUTTON_SELECT},  </div>
<div class="line">                                {BUTINC_VAL, BUTTON_INCREASE}, </div>
<div class="line">                                {BUTDEC_VAL, BUTTON_DECREASE}, </div>
<div class="line">                                {BUTREV_VAL, BUTTON_BACK}, </div>
<div class="line">                                {BUTFWD_VAL, BUTTON_FORWARD}</div>
<div class="line">                            };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> setup() {</div>
<div class="line"> </div>
<div class="line">   ...</div>
<div class="line"> </div>
<div class="line">     Menu.<a class="code" href="class_o_m_menu_mgr.html#a189699b2a1eed8b4083496f75eab51d7">setAnalogButtonPin</a>(BUT_PIN, BUT_MAP, BUT_THRESH);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>If you do not wish to use the forward button, it is not required. However, you must still specify five buttons in the array. To ignore the forward button (if you want to use only four, instead of five, buttons), simply make sure that BUTTON_FORWARD is the last element in the array, and re-use one of the earlier read values.</p>
<h1><a class="anchor" id="menupolling"></a>
Polling the Menu</h1>
<p>The menu must be polled regularly, such as during your loop() function, to check for input, display the menu, or interact with it. A single method is all that needs to be called for this activity.</p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> loop() {</div>
<div class="line">    </div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a>();</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --><p>This method returns the button pressed or BUTTON_NONE if none were, so you may also use it to handle user input if you need, and disable the menu if required, see:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> loop() {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>( hideMenu ) {</div>
<div class="line">        Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>(<span class="keyword">false</span>);</div>
<div class="line">        hideMenu = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    byte button = Menu.<a class="code" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>( ! Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>() ) {</div>
<div class="line">        <span class="comment">// menu is disabled</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>( button == BUTTON_SELECT ) {</div>
<div class="line">            <span class="comment">// do something!</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>( button == BUTTON_FORWARD ) {</div>
<div class="line">            <span class="comment">// re-enable Menu</span></div>
<div class="line">            Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> }</div>
</div><!-- fragment --><h1><a class="anchor" id="menudisplay"></a>
Managing Display</h1>
<p>While the Menu Manager creates the content for display, and manages what data should be displayed and when, it does not have any built-in display methodology. This allows you to use nearly any display you like, since you will be controlling how the data is sent to the display.</p>
<p>To achieve this, a callback model is used - you specify a function for each required display activity, and pass them as arguments to the set...Handler() methods.</p>
<p>Three functions are required: Draw, and Exit.</p>
<p>Draw handles displaying strings to the screen. It is passed four arguments: a character pointer, a row, a column, and the length of the characters stored at the address in the character pointer.</p>
<p><b>The character pointer will not always be null-terminated, and cannot be relied upon to be null-terminated. Always use the length argument, which can be relied upon.</b></p>
<p>The following shows a model handler for drawing using a standard LiquidCrystal object named 'lcd':</p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> setup() {</div>
<div class="line"> </div>
<div class="line">   ...</div>
<div class="line">  </div>
<div class="line">     Menu.<a class="code" href="class_o_m_menu_mgr.html#a1f4ce5a7db0116134f911b8f29dc1603">setDrawHandler</a>(uiDraw);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> uiDraw(<span class="keywordtype">char</span>* p_text, <span class="keywordtype">int</span> p_row, <span class="keywordtype">int</span> p_col, <span class="keywordtype">int</span> len) {</div>
<div class="line">    lcd.setCursor(p_col, p_row);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; len; i++ ) {</div>
<div class="line">        <span class="keywordflow">if</span>( p_text[i] &lt; <span class="charliteral">&#39;!&#39;</span> || p_text[i] &gt; <span class="charliteral">&#39;~&#39;</span> )</div>
<div class="line">            lcd.write(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">        <span class="keywordflow">else</span>  </div>
<div class="line">            lcd.write(p_text[i]);</div>
<div class="line">    }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Note that in the above function, we handle characters outside of the normal ascii range, as the MenuMgr cannot gaurantee that every character is displayable.</p>
<p>Exit is called when the user exits the menu, and it is cleared. It should bring you to whatever state you need to be when the menu isn't displayed.</p>
<p>The following is a model example of a clear callback handler:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> uiExit() {</div>
<div class="line"> </div>
<div class="line">    lcd.clear();</div>
<div class="line">    lcd.setCursor(0, 0);</div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Enter for Menu&quot;</span>);</div>
<div class="line"> }</div>
</div><!-- fragment --><h1><a class="anchor" id="menuparam"></a>
Setting Control Parameters</h1>
<p>Of course, not every display is the same. Display parameters are set at compile time, and controlled via define's.</p>
<p>Unfortunately, the Arduino IDE does not allow you to specify defines to the compiler, so you cannot effectively change these from the Arduino IDE. For other IDE users, you may re-define them via your build process. For Arduino IDE users, you will need to edit the library directly.</p>
<ul>
<li>
OM_MENU_ROWS <ul>
<li>
Default = 2 </li>
<li>
Number of rows in the display, minimum is 2 </li>
</ul>
</li>
<li>
OM_MENU_COLS <ul>
<li>
Default = 16 </li>
<li>
Number of columns (character width) in the display. This also controls the maximum length of any label for a menu item </li>
</ul>
</li>
<li>
OM_MENU_LBLLEN <ul>
<li>
Default = OM_MENU_COLS </li>
<li>
Maximum length of a select label, this can be used to reduce flash usage when only short labels are needed </li>
</ul>
</li>
<li>
OM_MENU_MAXDEPTH <ul>
<li>
Default = 3 </li>
<li>
Maximum nested depth of menus. You can go deeper than this, but menu history will not be retained below this level. </li>
</ul>
</li>
<li>
OM_MENU_DEBOUNCE <ul>
<li>
Default = 120 </li>
<li>
Debounce time for button input, in mS </li>
</ul>
</li>
<li>
OM_MENU_CURSOR <ul>
<li>
Default = "&gt;" </li>
<li>
Cursor to show for current item selection </li>
</ul>
</li>
<li>
OM_MENU_NOCURSOR <ul>
<li>
Default = " " </li>
<li>
Cursor to show for displayed items not currently selected </li>
</ul>
</li>
<li>
OM_MENU_USE_EEPROM <ul>
<li>
Default = Not Defined </li>
<li>
Support automatic writing of variables to EEPROM via <a class="el" href="namespace_o_m_e_e_p_r_o_m.html">OMEEPROM</a> library. For more info, see the <a class="el" href="class_o_m_menu_mgr.html#menueeprom">Automating EEPROM Writes</a> section below. </li>
</ul>
</li>
<li>
OM_MENU_FLAG_ON <ul>
<li>
Default = "On" </li>
<li>
The string to be displayed to the user for bit flag values where the flag is turned on </li>
</ul>
</li>
<li>
OM_MENU_FLAG_OFF <ul>
<li>
Default = "Off" </li>
<li>
The string to be displayed to the user for bit flag values where the flag is turned off </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="menueeprom"></a>
Automating EEPROM Writes</h1>
<p>The Menu Manager can automatically store changed variables to EEPROM for you, using the <a class="el" href="namespace_o_m_e_e_p_r_o_m.html">OMEEPROM</a> library. You can retrieve the data, do EEPROM format versioning, and more with the <a class="el" href="namespace_o_m_e_e_p_r_o_m.html">OMEEPROM</a> library.</p>
<p>Each menu value has a final parameter, with the EEPROM byte address to store the data. If you do not want to store the data in EEPROM, use 0 as the address, or simply not pass that parameter at all. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #include &quot;OMEEPROM.h&quot;</span></div>
<div class="line"><span class="preprocessor"> #include &quot;OMMenuMgr.h&quot;</span></div>
<div class="line"></div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> EEPROM_NOADDR    = 0;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> EEPROM_FOO       = 10;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> foo = 1;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bar = 1;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baz = 1;</div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> MENU_VALUE value_foo = { TYPE_UINT, 0, 0, MENU_TARGET(&amp;foo), EEPROM_FOO };</div>
<div class="line"> </div>
<div class="line"> MENU_VALUE value_bar = { TYPE_UINT, 0, 0, MENU_TARGET(&amp;foo), EEPROM_NOADDR };</div>
<div class="line"> MENU_VALUE value_baz = { TYPE_UINT, 0, 0, MENU_TARGET(&amp;baz) }; <span class="comment">// equivalent to providing no address at the end</span></div>
</div><!-- fragment --><p>Now, when these values are exercised by the user, foo will be stored to EEPROM, starting at byte 10, and bar will not be stored in EEPROM.</p>
<h1><a class="anchor" id="menuexample"></a>
A Complete Example</h1>
<p>The following is a complete example of a sketch with a menu:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;OMMenuMgr.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LiquidCrystal.h&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// lcd pins</span></div>
<div class="line"><span class="keyword">const</span> byte LCD_RS  = 17;</div>
<div class="line"><span class="keyword">const</span> byte LCD_EN  = 18;</div>
<div class="line"><span class="keyword">const</span> byte LCD_D4  = 11;</div>
<div class="line"><span class="keyword">const</span> byte LCD_D5  = 8;</div>
<div class="line"><span class="keyword">const</span> byte LCD_D6  = 7;</div>
<div class="line"><span class="keyword">const</span> byte LCD_D7  = 4;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> byte LCD_ROWS = 2;</div>
<div class="line"><span class="keyword">const</span> byte LCD_COLS = 16;</div>
<div class="line"></div>
<div class="line"><span class="comment">// button values</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// which input is our button</span></div>
<div class="line"><span class="keyword">const</span> byte BUT_PIN = 14;</div>
<div class="line"></div>
<div class="line"><span class="comment">// analog button read values</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUTSEL_VAL  = 70;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUTFWD_VAL  = 250;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUTREV_VAL  = 450;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUTDEC_VAL  = 655;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUTINC_VAL  = 830;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> byte BUT_THRESH  = 60;</div>
<div class="line"></div>
<div class="line"><span class="comment">// mapping of analog button values for menu</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUT_MAP[5][2] = {</div>
<div class="line">    {BUTFWD_VAL, BUTTON_FORWARD}, </div>
<div class="line">    {BUTINC_VAL, BUTTON_INCREASE}, </div>
<div class="line">    {BUTDEC_VAL, BUTTON_DECREASE}, </div>
<div class="line">    {BUTREV_VAL, BUTTON_BACK}, </div>
<div class="line">    {BUTSEL_VAL, BUTTON_SELECT} </div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ====== Test Menu =========== </span></div>
<div class="line"></div>
<div class="line">byte foo = 0;</div>
<div class="line">byte sel = 0;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bar = 1;</div>
<div class="line"><span class="keywordtype">long</span> baz  = 0;</div>
<div class="line"><span class="keywordtype">float</span> bak = 0.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a list of states and values for a select input</span></div>
<div class="line">MENU_SELECT_ITEM  sel_ign = { 2, {<span class="stringliteral">&quot;Ignore&quot;</span>} };</div>
<div class="line">MENU_SELECT_ITEM  sel_on  = { 1, {<span class="stringliteral">&quot;On&quot;</span>} };</div>
<div class="line">MENU_SELECT_ITEM  sel_off = { 0, {<span class="stringliteral">&quot;Off&quot;</span>} };</div>
<div class="line"></div>
<div class="line">MENU_SELECT_LIST  state_list[] = { &amp;sel_ign, &amp;sel_on, &amp;sel_off };</div>
<div class="line"></div>
<div class="line"><span class="comment">// the special target for our state input</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// TARGET VAR   LENGTH                          TARGET SELECT LIST</span></div>
<div class="line">MENU_SELECT state_select = { &amp;sel,           MENU_SELECT_SIZE(state_list),   MENU_TARGET(&amp;state_list) };</div>
<div class="line"></div>
<div class="line"><span class="comment">// values to use </span></div>
<div class="line"></div>
<div class="line"><span class="comment">//    TYPE            MAX    MIN    TARGET </span></div>
<div class="line">MENU_VALUE foo_value = { TYPE_BYTE,       100,   0,     MENU_TARGET(&amp;foo) };</div>
<div class="line">MENU_VALUE bar_value = { TYPE_UINT,       10000, 100,   MENU_TARGET(&amp;bar) };</div>
<div class="line">MENU_VALUE baz_value = { TYPE_LONG,       10000, 1,     MENU_TARGET(&amp;baz) };</div>
<div class="line">MENU_VALUE bak_value = { TYPE_FLOAT_1000, 0,     0,     MENU_TARGET(&amp;bak) };</div>
<div class="line">MENU_VALUE sel_value = { TYPE_SELECT,     0,     0,     MENU_TARGET(&amp;state_select) };</div>
<div class="line"></div>
<div class="line"><span class="comment">//        LABEL           TYPE        LENGTH    TARGET</span></div>
<div class="line">MENU_ITEM item_checkme  = { {<span class="stringliteral">&quot;Byte Edit&quot;</span>},    ITEM_VALUE,  0,        MENU_TARGET(&amp;foo_value) };</div>
<div class="line">MENU_ITEM item_barme    = { {<span class="stringliteral">&quot;UInt Edit&quot;</span>},     ITEM_VALUE,  0,        MENU_TARGET(&amp;bar_value) };</div>
<div class="line">MENU_ITEM item_bazme    = { {<span class="stringliteral">&quot;Long Edit&quot;</span>},    ITEM_VALUE,  0,        MENU_TARGET(&amp;baz_value) };</div>
<div class="line">MENU_ITEM item_bakme    = { {<span class="stringliteral">&quot;Float Edit&quot;</span>},   ITEM_VALUE,  0,        MENU_TARGET(&amp;bak_value) };</div>
<div class="line">MENU_ITEM item_state    = { {<span class="stringliteral">&quot;Select Input&quot;</span>}, ITEM_VALUE,  0,        MENU_TARGET(&amp;sel_value) };</div>
<div class="line">MENU_ITEM item_testme   = { {<span class="stringliteral">&quot;Test Action&quot;</span>},  ITEM_ACTION, 0,        MENU_TARGET(uiQwkScreen) };</div>
<div class="line"></div>
<div class="line"><span class="comment">//        List of items in menu level</span></div>
<div class="line">MENU_LIST root_list[]   = { &amp;item_checkme, &amp;item_barme, &amp;item_bazme, &amp;item_bakme, &amp;item_state, &amp;item_testme };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Root item is always created last, so we can add all other items to it</span></div>
<div class="line">MENU_ITEM menu_root     = { {<span class="stringliteral">&quot;Root&quot;</span>},        ITEM_MENU,   MENU_SIZE(root_list),    MENU_TARGET(&amp;root_list) };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// initialize LCD object</span></div>
<div class="line">LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_o_m_menu_mgr.html" title="The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.">OMMenuMgr</a> Menu(&amp;menu_root);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uiMenuSetup() {</div>
<div class="line">    </div>
<div class="line">    lcd.begin(LCD_COLS, LCD_ROWS);</div>
<div class="line">    </div>
<div class="line">    uiClear();</div>
<div class="line">    </div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a1f4ce5a7db0116134f911b8f29dc1603">setDrawHandler</a>(uiDraw);</div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a9e33a3a3eb68895e28225d66678280da">setExitHandler</a>(uiClear);</div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a189699b2a1eed8b4083496f75eab51d7">setAnalogButtonPin</a>(BUT_PIN, BUT_MAP, BUT_THRESH);</div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>(<span class="keyword">true</span>); </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uiCheck() {</div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a>();</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> testAction() {</div>
<div class="line">    </div>
<div class="line">    digitalWrite(5, HIGH);  </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uiDraw(<span class="keywordtype">char</span>* p_text, <span class="keywordtype">int</span> p_row, <span class="keywordtype">int</span> p_col, <span class="keywordtype">int</span> len) {</div>
<div class="line">    lcd.setCursor(p_col, p_row);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; len; i++ ) {</div>
<div class="line">        <span class="keywordflow">if</span>( p_text[i] &lt; <span class="charliteral">&#39;!&#39;</span> || p_text[i] &gt; <span class="charliteral">&#39;~&#39;</span> )</div>
<div class="line">            lcd.write(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">        <span class="keywordflow">else</span>  </div>
<div class="line">            lcd.write(p_text[i]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uiClear() {</div>
<div class="line">    </div>
<div class="line">    lcd.clear();</div>
<div class="line">    lcd.setCursor(0, 0);</div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Enter for Menu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uiQwkScreen() {</div>
<div class="line">    lcd.clear();</div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>(<span class="keyword">false</span>);</div>
<div class="line">    </div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Action!&quot;</span>);</div>
<div class="line">    lcd.setCursor(0, 1);</div>
<div class="line">    lcd.print(<span class="stringliteral">&quot;Enter 2 return&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span>( Menu.<a class="code" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a>() != BUTTON_SELECT ) {</div>
<div class="line">        ; <span class="comment">// wait!</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Menu.<a class="code" href="class_o_m_menu_mgr.html#a34a5df068f1cb8b15e3e39accfc71b46">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">    lcd.clear();</div>
<div class="line">}  </div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_o_m_menu_mgr_8h_source.html#l00910">910</a> of file <a class="el" href="_o_m_menu_mgr_8h_source.html">OMMenuMgr.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c9f9a0226f69fa23b9efb450642bc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_m_menu_mgr.html">OMMenuMgr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> *&#160;</td>
          <td class="paramname"><em>c_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c_type</em> = <code>MENU_ANALOG</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>Constructs an <a class="el" href="class_o_m_menu_mgr.html" title="The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.">OMMenuMgr</a> instance, with a specified root item, and a specified input type.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #include &quot;OMMenuMgr.h&quot;</span></div>
<div class="line"> </div>
<div class="line"> ...</div>
<div class="line"> </div>
<div class="line"> <a class="code" href="class_o_m_menu_mgr.html" title="The OpenMoCo Menu Manager provides a nearly complete automation of a menuing system. This class is designed to allow for rapid development of menuing systems on Arduino devices, using five input controls (buttons), and character displays of at least two rows.">OMMenuMgr</a> Menu = <a class="code" href="class_o_m_menu_mgr.html#a7c9f9a0226f69fa23b9efb450642bc16">OMMenuMgr</a>(&amp;rootItem, MENU_ANALOG);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_first</td><td>A pointer to an <a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> representing the root of the menu</td></tr>
    <tr><td class="paramname">c_type</td><td>The input type for the menu, either MENU_ANALOG or MENU_DIGITAL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00051">51</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ade4543555c00c157c4018b76da05b9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t checkInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for User Input and Handle</p>
<p>Checks to see if any button has been pressed by the user, and reports back the button pressed, or BUTTON_NONE if none are pressed.</p>
<p>If the menu is enabled and drawn, and any button is pressed, normal handling of the menu is executed. If the menu is enabled, but not drawn, the menu will be drawn only if BUTTON_SELECT is pressed. Otherwise, no activity will occur.</p>
<dl class="section return"><dt>Returns:</dt><dd>The button pressed, one of: BUTTON_NONE, BUTTON_FORWARD, BUTTON_BACK, BUTTON_INCREASE, BUTTON_DECREASE, BUTTON_SELECT </dd></dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00221">221</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34a5df068f1cb8b15e3e39accfc71b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>p_en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or Disable Handling of Menu</p>
<p>You may disable handling of menu to allow the class instance to just poll and report back the currently pressed button. This is particularly useful when executing actions from menu items, where the user input is needed.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_en</td><td>Enable (true), or disable (false) menu display </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00314">314</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bf7bbb045003f05fbb63d6418fb19a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Enable Status</p>
<p>Returns the current enable status</p>
<dl class="section return"><dt>Returns:</dt><dd>Enable status </dd></dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00326">326</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad05b6293f26577d9aa161f5e4b50ccda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int holdModifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Hold Modifier</p>
<p>If a button is held by the user, the hold modifier is increased every OM_MENU_DEBOUNCE period of time. In between these time periods, <a class="el" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput()</a> returns BUTTON_NONE, to prevent duplication of input (e.g. bouncing).</p>
<p>By checking this value, you can determine the difference between a button being held (hold modifier &gt; 1) and debounced, and no button being pressed. E.g.:</p>
<div class="fragment"><div class="line"> byte          button = Menu.<a class="code" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput</a>();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> holdMod = Menu.<a class="code" href="class_o_m_menu_mgr.html#ad05b6293f26577d9aa161f5e4b50ccda">holdModifier</a>();</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span>( button == BUTTON_NONE &amp;&amp; holdMod &gt; 1 ) {</div>
<div class="line">    <span class="comment">// last button press is held!</span></div>
<div class="line"> }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( button != BUTTON_NONE ) {</div>
<div class="line">    <span class="comment">// a button is pressed for the first time, or being</span></div>
<div class="line">    <span class="comment">// held for the first debounce cycle</span></div>
<div class="line"> }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// no button is pressed at all</span></div>
<div class="line"> }</div>
</div><!-- fragment --><dl class="section return"><dt>Returns:</dt><dd>Hold modifier, &gt;= 1 </dd></dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00375">375</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a189699b2a1eed8b4083496f75eab51d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAnalogButtonPin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>p_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p_values</em>[5][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup Analog Button Input</p>
<p>For UI's with multiple buttons assigned to a single analog pin (e.g. using a resistor network to report different values), this method allows you to specify how this pin shall be read.</p>
<p>This method is NOOP if the menu type is not MENU_ANALOG</p>
<p>The digital pin # is specified, along with an array of values and their meanings, and a threshold for those values. The array of values and meanings should be two-dimensional with two values in the second dimension, and five rows in the first dimension. The two values shall represent the integer value of analogRead() assigned to that button, and the button type. e.g.:</p>
<div class="fragment"><div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span>[5][2] myButtons = { {150, BUTTON_FORWARD}, </div>
<div class="line">                         {250, BUTTON_INCREASE}, </div>
<div class="line">                         {350, BUTTON_DECREASE}, </div>
<div class="line">                         {450, BUTTON_BACK}, </div>
<div class="line">                         {550, BUTTON_SELECT} </div>
<div class="line">                        };</div>
<div class="line"> </div>
<div class="line"> Menu.<a class="code" href="class_o_m_menu_mgr.html#a189699b2a1eed8b4083496f75eab51d7">setAnalogButtonPin</a>(14, myButtons, 25);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_pin</td><td>The Arduino Digital Pin to use</td></tr>
    <tr><td class="paramname">p_values</td><td>The list of button values and function</td></tr>
    <tr><td class="paramname">p_thresh</td><td>The threshold deviation from the specified value to match the button read. You must provide some threshold, as the analogRead() values will vary. The range of value to be matched for each button is between (value - thresh) and (value + thresh). This threshold should be large enough to account for the variation in your circuit, but by no means should two button values overlap. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00106">106</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16e9d84692b4abee1c7af7a07ce6c48a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDigitalButtonPins </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p_values</em>[5][2]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup Digital Button Input</p>
<p>For UI's with digital button input (e.g. one digital input per button), this method allows you to specify the pins for digital input.</p>
<p>An array is passed that defines, for each button, it's digital pin and function. There must be two dimensions, with five rows and two data elements. The first data element indicates the Arduino digital pin, and the second element indicates the function.</p>
<p>For example:</p>
<div class="fragment"><div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span>[5][2] myButtons = { {4, BUTTON_FORWARD}, </div>
<div class="line">                         {5, BUTTON_INCREASE}, </div>
<div class="line">                         {6, BUTTON_DECREASE}, </div>
<div class="line">                         {7, BUTTON_BACK}, </div>
<div class="line">                         {8, BUTTON_SELECT} </div>
<div class="line">                        };</div>
<div class="line"> </div>
<div class="line"> Menu.<a class="code" href="class_o_m_menu_mgr.html#a16e9d84692b4abee1c7af7a07ce6c48a">setDigitalButtonPins</a>(myButtons);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_values</td><td>The list of button values and functions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00150">150</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f4ce5a7db0116134f911b8f29dc1603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDrawHandler </td>
          <td>(</td>
          <td class="paramtype">void(*)(char *, int, int, int)&#160;</td>
          <td class="paramname"><em>p_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Draw Handler Callback</p>
<p>Sets the draw handler callback, see <a class="el" href="class_o_m_menu_mgr.html#menudisplay">Managing Display</a> for more information</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_func</td><td>A function pointer for the draw handler </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00177">177</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e33a3a3eb68895e28225d66678280da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setExitHandler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>p_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Exit Handler Callback</p>
<p>Sets the exit handler callback, see <a class="el" href="class_o_m_menu_mgr.html#menudisplay">Managing Display</a> for more information</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_func</td><td>A function pointer for the exit handler </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00191">191</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1673397a534ccd405c4dcebbf6443b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> *&#160;</td>
          <td class="paramname"><em>p_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set New Root Item</p>
<p>Sets new root item as the base for future calls to <a class="el" href="class_o_m_menu_mgr.html#ade4543555c00c157c4018b76da05b9b3">checkInput()</a>;</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_root</td><td>A pointer to an <a class="el" href="struct_o_m_menu_item.html">OMMenuItem</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00338">338</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60f1026509c85417954a6c578d64e1ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Menu Shown State</p>
<p>Whether or not the menu is currently being displayed.</p>
<dl class="section return"><dt>Returns:</dt><dd>Whether or the menu is currently displayed (true), or not (false) </dd></dl>

<p>Definition at line <a class="el" href="_o_m_menu_mgr_8cpp_source.html#l00204">204</a> of file <a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_o_m_menu_mgr_8h_source.html">OMMenuMgr.h</a></li>
<li><a class="el" href="_o_m_menu_mgr_8cpp_source.html">OMMenuMgr.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_o_m_menu_mgr.html">OMMenuMgr</a></li>
    <li class="footer">Generated on Wed Aug 14 2013 13:14:08 for OpenMoCo AVR Libraries by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
