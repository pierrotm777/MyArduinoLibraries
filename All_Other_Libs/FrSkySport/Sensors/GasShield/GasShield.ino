#define ProvideLQ // if not defined does not report LQ
// For ACCESS receivers it is redundant

#include <SPort.h>
// Stuff for deconding the sbus stream
#define SBUS_BAUD 100000
#define SBUS_BUFFER 25


// Define the parameters of the RPM sensor and LQ Sensors
// Change the SENSOR_ID to suit
#define PHYSICAL_ID 0x12
#ifdef ProvideLQ
#define LQ_SENSOR_ID 0x5100
#endif
#define RPM_SENSOR_ID 0X5200
#define FS_SENSOR_ID 0x5300
#define CH16_SENSOR_ID 0X5400
//#define CH8_SENSOR_ID 0X5500
#define SPORT_PIN 2 // Sport output connects to pin 2
#define RPM_INPUT_PIN 3 // Signal from optocoupler connects to pin 3
#define BLINKING_PERIOD 200 // 
// to avoid accidentally turning off the ignition,
// we require that a minimum number of consecutive
// frames have ignition kill set to trigger it
// The number should be between 1 and 32
#define MINUMUM_FRAMES_TO_TRIGGER_IGNITION_KILL 32

// RPM is calculated counting the number of pulses
// generated by the ingnition pickup coil in one second
// To minimize the time spent in the interrupt service routine
// we use a byte to store the number of pulses.
// This limit the number of pulses in 1 second to 255,
// which translates to a max RPM of 255*60=15300 RPM
// with a granularity of 60 RPM. This should be enough
// for the majority of engines out there that use a magneto
// ignition.
volatile byte pulseCounter = 0;
/*
volatile unsigned long Interval = 0;
volatile bool newVal = false;
*/

#define IGNITION_KILL_PIN 4 // hardwired on the shield
// these can change
#define IGNITION_LED_PIN 5
#define LIGHTS_ON_PIN1 6
#define LIGHTS_ON_PIN2 7
#define IGNITION_CHANNEL 16 // channel on radio that controls ignition
#define LIGHTS_CHANNEL 15 // channel on radio that controls lights

SPortHub hub(PHYSICAL_ID, SPORT_PIN);
SimpleSPortSensor RPMSensor(RPM_SENSOR_ID);
#ifdef ProvideLQ
SimpleSPortSensor LQSensor(LQ_SENSOR_ID);
#endif
SimpleSPortSensor FSSensor(FS_SENSOR_ID);
SimpleSPortSensor CH16Sensor(CH16_SENSOR_ID);
//SimpleSPortSensor CH8Sensor(CH8_SENSOR_ID);
int channels[16]; // the 16 channels
bool failsafe; // the failsafe status of the last frame
#ifdef ProvideLQ
uint32_t lastFrameLossesBuffer; //the 32 bits contain the value of frameLost
// over the last 32 received frames.
#endif

uint32_t killMask = 0; //used to determine when to kill ignition

bool hadFailsafe = false; //turns true if at least one failsafe was recorded.
bool hasSpark = false; //turns true if at least one spark was detected.
void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(IGNITION_KILL_PIN, OUTPUT);
  pinMode(IGNITION_LED_PIN, OUTPUT);
  pinMode(LIGHTS_ON_PIN1, OUTPUT);
  pinMode(LIGHTS_ON_PIN2, OUTPUT);

  // at boot time, ligths are off, ignition is on!
  // this to avoid that a reset in flight may kill the engine
  // before signal is reacquired from the Rx
  digitalWrite(LIGHTS_ON_PIN1, LOW);
  digitalWrite(LIGHTS_ON_PIN2, LOW);
  digitalWrite(IGNITION_KILL_PIN, LOW);
  digitalWrite(IGNITION_LED_PIN, HIGH);

  channels[IGNITION_CHANNEL - 1] = 0;
  channels[LIGHTS_CHANNEL - 1] = 0x7FF;
  // set the first MINUMUM_FRAMES_TO_TRIGGER_IGNITION_KILL bits in killMask to 1
  for (int i = 0; i < MINUMUM_FRAMES_TO_TRIGGER_IGNITION_KILL; ++i)
  {
    killMask = ((killMask << 1) | 0x01);
  }
  // register and initialize the sensor
  hub.registerSensor(RPMSensor);
#ifdef ProvideLQ
  hub.registerSensor(LQSensor);
#endif
  hub.registerSensor(FSSensor);
  hub.registerSensor(CH16Sensor);
  //  hub.registerSensor(CH8Sensor);

  hub.begin();
  RPMSensor.value = 0;
#ifdef ProvideLQ
  LQSensor.value = 100;
#endif
  FSSensor.value = 0;
  CH16Sensor.value = channels[15];
  //CH8Sensor.value = channels[7];

  // start monitoring the RPM pin
  pinMode(RPM_INPUT_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(RPM_INPUT_PIN), pulseISR, RISING);
  // start reading the SBUS stream
  Serial.begin(SBUS_BAUD,  SERIAL_8E2);
}

void loop() {

  detachInterrupt(digitalPinToInterrupt(RPM_INPUT_PIN));
  readSBusFrame();
  attachInterrupt(digitalPinToInterrupt(RPM_INPUT_PIN), pulseISR, RISING);

#ifdef ProvideLQ
  setLQSensor();
#endif
  setRPMSensor();
  setFSSensor();

  CH16Sensor.value = channels[15];
  //CH8Sensor.value = channels[7];
  hub.handle();
  hasSpark = hasSpark || pulseCounter>0;
  setOutputs(hadFailsafe, hasSpark);
}

// this routine blocks until a full frame is received!
// adapted from LQSensor
void readSBusFrame()
{ static  unsigned long sbusIndex = 0;
  static   byte sbusPreviousValue = 0;
  static   bool sbusInFrame = false;
  // get an SBus frame
  while (Serial.available() > 0) {
    const byte value = Serial.read();
    int sbusBuffer[SBUS_BUFFER];
    //Only start a new frame if everything lines up correctly
    if (!sbusInFrame && value == 0x0F && sbusPreviousValue == 0x00) {
      sbusIndex = 0;
      sbusInFrame = true;
    }
    //When in frame, store the value in the buffer
    if (sbusInFrame) {
      sbusBuffer[sbusIndex++] = value;

      //If all 25 bytes are received in the frame, handle it
      if (sbusIndex == 25) {
        sbusInFrame = false; //Stop capturing
        decodeSBusFrame(sbusBuffer);
        sbusPreviousValue = value; //stores last byte (0x00)
        return; // leave while loop
      }
    } // end of sbusinFrame loop



  } //end of while
}

void decodeSBusFrame(int sbusBuffer[])
{ // this code adapted  from http://www.robotmaker.eu/ROBOTmaker/quadcopter-3d-proximity-sensing/sbus-graphical-representation
  // see there for a description of the way the data in the buffer is handled.
  channels[0]  = ((sbusBuffer[1]      | sbusBuffer[2] << 8) & 0x07FF); //The first Channel
  channels[1]  = ((sbusBuffer[2] >> 3 | sbusBuffer[3] << 5)  & 0x07FF); // the second channel
  channels[2]  = ((sbusBuffer[3] >> 6 | sbusBuffer[4] << 2 | sbusBuffer[5] << 10)  & 0x07FF);
  channels[3]  = ((sbusBuffer[5] >> 1 | sbusBuffer[6] << 7) & 0x07FF);
  channels[4]  = ((sbusBuffer[6] >> 4 | sbusBuffer[7] << 4) & 0x07FF);
  channels[5]  = ((sbusBuffer[7] >> 7 | sbusBuffer[8] << 1 | sbusBuffer[9] << 9)   & 0x07FF);
  channels[6]  = ((sbusBuffer[9] >> 2 | sbusBuffer[10] << 6) & 0x07FF);
  channels[7]  = ((sbusBuffer[10] >> 5 | sbusBuffer[11] << 3) & 0x07FF);
  channels[8]  = ((sbusBuffer[12]   | sbusBuffer[13] << 8) & 0x07FF);
  channels[9]  = ((sbusBuffer[13] >> 3 | sbusBuffer[14] << 5)  & 0x07FF);
  channels[10] = ((sbusBuffer[14] >> 6 | sbusBuffer[15] << 2 | sbusBuffer[16] << 10) & 0x07FF);
  channels[11] = ((sbusBuffer[16] >> 1 | sbusBuffer[17] << 7) & 0x07FF);
  channels[12] = ((sbusBuffer[17] >> 4 | sbusBuffer[18] << 4) & 0x07FF);
  channels[13] = ((sbusBuffer[18] >> 7 | sbusBuffer[19] << 1 | sbusBuffer[20] << 9)  & 0x07FF);
  channels[14] = ((sbusBuffer[20] >> 2 | sbusBuffer[21] << 6) & 0x07FF);
  channels[15] = ((sbusBuffer[21] >> 5 | sbusBuffer[22] << 3) & 0x07FF);
#ifdef ProvideLQ
  lastFrameLossesBuffer = lastFrameLossesBuffer << 1 | ((sbusBuffer[23] & 0b0100) ? 1 : 0);
#endif
  failsafe = (sbusBuffer[23] & 0b1000) ? true : false;

}
void setRPMSensor()
{ 
  
  static unsigned long past = 0;
  const unsigned long current = millis();
  if (current - past >= 1000)
  {
    RPMSensor.value = (int)((double)pulseCounter * (double)(60 * (current-past))/double(1000));
    pulseCounter = 0;
    past = current;
  }
  
  /*
  if (newVal) {
    hasSpark = newVal;
    noInterrupts();
    double freq = double(1000000) / double(Interval);
    newVal = false;
    interrupts();
    RPMSensor.value = (int)(freq * 60);
  }
*/
}

#ifdef ProvideLQ
void setLQSensor() {
  LQSensor.value = (double)(32 - countNonZeroBits(lastFrameLossesBuffer)) / 32.*100;
}

uint32_t countNonZeroBits(uint32_t n)
{ //
  const uint32_t masks[] = { 0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF };

  for (unsigned i = 0; i < 5; i++) {
    n = (n & masks[i]) + ((n >> (1 << i)) & masks[i]);
  }

  return n;
}
#endif


void setFSSensor() {
  static int failsafeCounter = 0;
  static bool previouslyInFailsafe = false;
  if (failsafe && !previouslyInFailsafe)
  {
    ++failsafeCounter;
    previouslyInFailsafe = true;
  }
  previouslyInFailsafe = failsafe;
  FSSensor.value = failsafeCounter;
  hadFailsafe = failsafeCounter > 0;
}

void setOutputs(bool hadFailsafe, bool sparkDetected)
{ static uint32_t ignitionKillBuffer = 0;
  ignitionKillBuffer = ignitionKillBuffer << 1 | ((channels[IGNITION_CHANNEL - 1] > 1024) ? 1 : 0);
  const bool lightsOn = channels[LIGHTS_CHANNEL - 1] > 1024;
  const bool ignitionKill = (ignitionKillBuffer & killMask) == killMask;

  if (lightsOn) {
    digitalWrite(LIGHTS_ON_PIN1, HIGH);
    digitalWrite(LIGHTS_ON_PIN2, HIGH);
  } else
  {
    digitalWrite(LIGHTS_ON_PIN1, LOW);
    digitalWrite(LIGHTS_ON_PIN2, LOW);
  }
  if (ignitionKill) {
    digitalWrite(IGNITION_KILL_PIN, HIGH); //kills ignition
    digitalWrite(IGNITION_LED_PIN, LOW);
    blinkOnboardLED(hadFailsafe);
    hasSpark = false;
    pulseCounter = 0;
  } else
  {
    digitalWrite(IGNITION_KILL_PIN, LOW);
    digitalWrite(IGNITION_LED_PIN, HIGH);
    if (sparkDetected){
    digitalWrite(LED_BUILTIN, HIGH);
    }else
    {
     blinkOnboardLED(true); 
    }
  }
}

void blinkOnboardLED(bool yes)
{ static unsigned long past = 0;
  static bool onboardLEDOn = false;
  if (yes) {
    const unsigned long current = millis();
    if (current - past > BLINKING_PERIOD)
    {
      onboardLEDOn = onboardLEDOn ? false : true;
      past = current;
    }
  }
  else
  {
    onboardLEDOn = false;
  }
  digitalWrite(LED_BUILTIN, onboardLEDOn ? HIGH : LOW);
}

void pulseISR()
{ /*static unsigned long previousTime = 0;
  unsigned long now = micros();
  Interval = now - previousTime;
  previousTime = now;
  newVal = true;
  */
  ++pulseCounter;


}
