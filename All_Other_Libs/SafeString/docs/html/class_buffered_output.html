<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SafeString: BufferedOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SafeString
   &#160;<span id="projectnumber">4.1.27</span>
   </div>
   <div id="projectbrief">SafeString is a safe, robust and debuggable replacement for string processing in Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_buffered_output.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_buffered_output-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BufferedOutput Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>To create a <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> use the macro <b>createBufferedOutput</b> see the detailed description.  
 <a href="class_buffered_output.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_buffered_output_8h_source.html">BufferedOutput.h</a>&gt;</code></p>

<p>Inherits Stream.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a160c2523f7c8a526c2229d8cc2658166"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a160c2523f7c8a526c2229d8cc2658166">BufferedOutput</a> (size_t _bufferSize, uint8_t *_buf, <a class="el" href="_buffered_output_8h.html#aa36d6a8cb6f6e6721788347dc82e296a">BufferedOutputMode</a>=<a class="el" href="_buffered_output_8h.html#aa36d6a8cb6f6e6721788347dc82e296aafe97e31a97b909a0e0f21029f0c3c629">BLOCK_IF_FULL</a>, bool allOrNothing=true)</td></tr>
<tr class="memdesc:a160c2523f7c8a526c2229d8cc2658166"><td class="mdescLeft">&#160;</td><td class="mdescRight">use <a class="el" href="_buffered_output_8h.html#a2b5bbd95cae7c0e9ea92887a67cdfb5e" title="BufferedOutput.h by Matthew Ford (c)2020 Forward Computing and Control Pty.">createBufferedOutput(name, size, mode)</a>; instead <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a>(size_t _bufferSize, uint8_t *_buf, BufferedOutputMode = BLOCK_IF_FULL, bool allOrNothing = true);  <a href="class_buffered_output.html#a160c2523f7c8a526c2229d8cc2658166">More...</a><br /></td></tr>
<tr class="separator:a160c2523f7c8a526c2229d8cc2658166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52dc19177a4e72b6cff5f1ed078b95f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#ab52dc19177a4e72b6cff5f1ed078b95f">connect</a> (HardwareSerial &amp;_serial)</td></tr>
<tr class="memdesc:ab52dc19177a4e72b6cff5f1ed078b95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_buffered_output.html#ab52dc19177a4e72b6cff5f1ed078b95f" title="void connect(HardwareSerial&amp; _serial); // the output to write to, can also read from serial – the Har...">connect(HardwareSerial&amp; _serial)</a>; // the output to write to, can also read from serial &ndash; the HardwareSerial to buffer output to, usually Serial.  <a href="class_buffered_output.html#ab52dc19177a4e72b6cff5f1ed078b95f">More...</a><br /></td></tr>
<tr class="separator:ab52dc19177a4e72b6cff5f1ed078b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66c0ba763f5ec1321bac5fef3c1e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a4f66c0ba763f5ec1321bac5fef3c1e97">connect</a> (Stream &amp;_stream, const uint32_t baudRate=0)</td></tr>
<tr class="memdesc:a4f66c0ba763f5ec1321bac5fef3c1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_buffered_output.html#a4f66c0ba763f5ec1321bac5fef3c1e97" title="void connect(Stream&amp; _stream, const uint32_t baudRate); // the stream to write to and how fast to wri...">connect(Stream&amp; _stream, const uint32_t baudRate)</a>; // the stream to write to and how fast to write output, can also read from stream &ndash; the stream to buffer output to baudRate &ndash; the maximum rate at which the bytes are to be released.  <a href="class_buffered_output.html#a4f66c0ba763f5ec1321bac5fef3c1e97">More...</a><br /></td></tr>
<tr class="separator:a4f66c0ba763f5ec1321bac5fef3c1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a2ef199c9f2a3c3c7f1aac9027eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#af25a2ef199c9f2a3c3c7f1aac9027eb5">nextByteOut</a> ()</td></tr>
<tr class="separator:af25a2ef199c9f2a3c3c7f1aac9027eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf88bb274d39b752e388efc2c139257"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#aedf88bb274d39b752e388efc2c139257">write</a> (uint8_t)</td></tr>
<tr class="separator:aedf88bb274d39b752e388efc2c139257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd4dcb4b18cda23c5d88c200d334f7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#ab0bd4dcb4b18cda23c5d88c200d334f7">write</a> (const uint8_t *buf, size_t size)</td></tr>
<tr class="separator:ab0bd4dcb4b18cda23c5d88c200d334f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4b44f4db66043b70934660890e12a0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a3a4b44f4db66043b70934660890e12a0">available</a> ()</td></tr>
<tr class="separator:a3a4b44f4db66043b70934660890e12a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d183e5d4084676849bbe5df70184774"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a5d183e5d4084676849bbe5df70184774">read</a> ()</td></tr>
<tr class="separator:a5d183e5d4084676849bbe5df70184774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03bf2140a790975b905007b628bb6fe"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#ab03bf2140a790975b905007b628bb6fe">peek</a> ()</td></tr>
<tr class="separator:ab03bf2140a790975b905007b628bb6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab063ee4a76eca24bacae35f7c9ad3828"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#ab063ee4a76eca24bacae35f7c9ad3828">flush</a> ()</td></tr>
<tr class="separator:ab063ee4a76eca24bacae35f7c9ad3828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe607ac0f16e11656518799eb8bfdf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a3cfe607ac0f16e11656518799eb8bfdf">availableForWrite</a> ()</td></tr>
<tr class="separator:a3cfe607ac0f16e11656518799eb8bfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4e9f49544294c1fae95038aea2f00c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a3e4e9f49544294c1fae95038aea2f00c">getSize</a> ()</td></tr>
<tr class="separator:a3e4e9f49544294c1fae95038aea2f00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54957d6eed14d500dd7d5510c8e57b68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a54957d6eed14d500dd7d5510c8e57b68">clearSpace</a> (size_t len)</td></tr>
<tr class="separator:a54957d6eed14d500dd7d5510c8e57b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3262fc544642f3f42e4f60b887ec1836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a3262fc544642f3f42e4f60b887ec1836">protect</a> ()</td></tr>
<tr class="separator:a3262fc544642f3f42e4f60b887ec1836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfad652c5bc9476d4cd8d706af6ef071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#adfad652c5bc9476d4cd8d706af6ef071">clear</a> ()</td></tr>
<tr class="separator:adfad652c5bc9476d4cd8d706af6ef071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14278ab80fbfd64e6f463e1dc957ae5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_output.html#a14278ab80fbfd64e6f463e1dc957ae5f">terminateLastLine</a> ()</td></tr>
<tr class="separator:a14278ab80fbfd64e6f463e1dc957ae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>To create a <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> use the macro <b>createBufferedOutput</b> see the detailed description. </p>
<p>The createBufferedOutput macro takes 2, 3 or 4 arguments.<br  />
</p>
<p><a class="el" href="_buffered_output_8h.html#a2b5bbd95cae7c0e9ea92887a67cdfb5e" title="BufferedOutput.h by Matthew Ford (c)2020 Forward Computing and Control Pty.">createBufferedOutput(name, size)</a>; creates a <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> called <em>name</em> which can buffer upto <em>size</em> chars without blocking and then will block once the buffer fills up.<br  />
 This default blocking when the buffer is full is not recommended.<br  />
</p>
<p>Add a call to <br  />
 <code>bufferedOutput.nextByteOut();</code><br  />
 at the top of the loop() to release the buffered chars. You can add more of these calls through out the loop() code if needed.<br  />
 Most <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> methods also release the buffered chars.<br  />
</p>
<p><a class="el" href="_buffered_output_8h.html#a2b5bbd95cae7c0e9ea92887a67cdfb5e" title="BufferedOutput.h by Matthew Ford (c)2020 Forward Computing and Control Pty.">createBufferedOutput(name, size, mode )</a>; creates a <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> called <em>name</em> which can buffer upto <em>size</em> chars without blocking and mode determines what to do when the buffer is full.<br  />
 <b>mode</b> can be one of <b>BLOCK_IF_FULL</b>, <b>DROP_UNTIL_EMPTY</b> or <b>DROP_IF_FULL</b><br  />
 <b>BLOCK_IF_FULL</b> just blocks until some chars can be sent to the output stream, so freeing up space in the buffer to accept more output. This mode is not recommended, but can be used for testing to force ALL output to be sent.<br  />
 <b>DROP_UNTIL_EMPTY</b> will drop further output until all the output currently in the full buffer is sent to the output stream.<br  />
 <b>DROP_IF_FULL</b> will drop further output until enough chars have been sent to the output stream to free up space for the output printed to the buffer.<br  />
</p>
<p>If any chars are dropped then <b>~~</b> is added to the output sent so you can see where there is missing output.</p>
<p>This 3 argument version uses the default AllOrNothing == true setting. If the whole print(..) cannot fit in the buffer none of it is sent.</p>
<p><a class="el" href="_buffered_output_8h.html#a2b5bbd95cae7c0e9ea92887a67cdfb5e" title="BufferedOutput.h by Matthew Ford (c)2020 Forward Computing and Control Pty.">createBufferedOutput(name, size, mode, allOrNothing )</a>; creates a <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a> called <em>name</em> which can buffer upto <em>size</em> chars without blocking and mode determines what to do when the buffer is full and how to handle prints that do not entirely fit in the buffer.<br  />
 AllOrNothing true will drop the entire print( ) if it will not completely fit in the buffer.<br  />
 AllOrNothing false will only drop the part of the print( ) that will not fit in the buffer.<br  />
</p>
<p>See <a href="https://www.forward.com.au/pfod/ArduinoProgramming/Serial_IO/index.html#bufferedOutput">Arduino Serial I/O for the Real World - BufferedOutput</a> for an example of its use. </p>

<p class="definition">Definition at line <a class="el" href="_buffered_output_8h_source.html#l00078">78</a> of file <a class="el" href="_buffered_output_8h_source.html">BufferedOutput.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a160c2523f7c8a526c2229d8cc2658166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160c2523f7c8a526c2229d8cc2658166">&#9670;&nbsp;</a></span>BufferedOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferedOutput::BufferedOutput </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_buffered_output_8h.html#aa36d6a8cb6f6e6721788347dc82e296a">BufferedOutputMode</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="_buffered_output_8h.html#aa36d6a8cb6f6e6721788347dc82e296aafe97e31a97b909a0e0f21029f0c3c629">BLOCK_IF_FULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allOrNothing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use <a class="el" href="_buffered_output_8h.html#a2b5bbd95cae7c0e9ea92887a67cdfb5e" title="BufferedOutput.h by Matthew Ford (c)2020 Forward Computing and Control Pty.">createBufferedOutput(name, size, mode)</a>; instead <a class="el" href="class_buffered_output.html" title="To create a BufferedOutput use the macro createBufferedOutput see the detailed description.">BufferedOutput</a>(size_t _bufferSize, uint8_t *_buf, BufferedOutputMode = BLOCK_IF_FULL, bool allOrNothing = true); </p>
<p>buf &ndash; the user allocated buffer to store the bytes, must be at least bufferSize long. Defaults to an internal 8 char buffer if buf is omitted or NULL bufferSize &ndash; number of bytes to buffer,max bufferSize is limited to 32766. Defaults to an internal 8 char buffer if bufferSize is &lt; 8 or is omitted mode &ndash; BLOCK_IF_FULL (default), DROP_UNTIL_EMPTY or DROP_IF_FULL BLOCK_IF_FULL, like normal print, but with a buffer. Use this to see ALL the output, but will block the loop() when the output buffer fills DROP_UNTIL_EMPTY, when the output buffer is full, drop any more chars until it completely empties. ~~&lt;CR&gt;&lt;NL&gt; is inserted in the output to show chars were dropped. Useful when there too much output. It allow multiple prints to be output consecutively to give meaning full output avaliableForWrite() will return 0 from when the buffer fills until is empties DROP_IF_FULL, when the output buffer is full, drop any more chars until here is space. ~~&lt;CR&gt;&lt;NL&gt; is inserted in the output to show chars were dropped. allOrNothing &ndash; defaults to true, If true AND output buffer not empty then if write(buf,size) will not all fit don't output any of it. Else if false OR output buffer is empty then write(buf,size) will output partial data to fill output buffer. allOrNothing setting is ignored if mode is BLOCK_IF_FULL </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a4b44f4db66043b70934660890e12a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4b44f4db66043b70934660890e12a0">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BufferedOutput::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfe607ac0f16e11656518799eb8bfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe607ac0f16e11656518799eb8bfdf">&#9670;&nbsp;</a></span>availableForWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BufferedOutput::availableForWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfad652c5bc9476d4cd8d706af6ef071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfad652c5bc9476d4cd8d706af6ef071">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedOutput::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54957d6eed14d500dd7d5510c8e57b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54957d6eed14d500dd7d5510c8e57b68">&#9670;&nbsp;</a></span>clearSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BufferedOutput::clearSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab52dc19177a4e72b6cff5f1ed078b95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52dc19177a4e72b6cff5f1ed078b95f">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedOutput::connect </td>
          <td>(</td>
          <td class="paramtype">HardwareSerial &amp;&#160;</td>
          <td class="paramname"><em>_serial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void <a class="el" href="class_buffered_output.html#ab52dc19177a4e72b6cff5f1ed078b95f" title="void connect(HardwareSerial&amp; _serial); // the output to write to, can also read from serial – the Har...">connect(HardwareSerial&amp; _serial)</a>; // the output to write to, can also read from serial &ndash; the HardwareSerial to buffer output to, usually Serial. </p>
<p>You must call <a class="el" href="class_buffered_output.html#af25a2ef199c9f2a3c3c7f1aac9027eb5">nextByteOut()</a> each loop() in order to release the buffered chars. </p>

</div>
</div>
<a id="a4f66c0ba763f5ec1321bac5fef3c1e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f66c0ba763f5ec1321bac5fef3c1e97">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedOutput::connect </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void <a class="el" href="class_buffered_output.html#a4f66c0ba763f5ec1321bac5fef3c1e97" title="void connect(Stream&amp; _stream, const uint32_t baudRate); // the stream to write to and how fast to wri...">connect(Stream&amp; _stream, const uint32_t baudRate)</a>; // the stream to write to and how fast to write output, can also read from stream &ndash; the stream to buffer output to baudRate &ndash; the maximum rate at which the bytes are to be released. </p>
<p>Bytes will be relased slower depending on how long your loop() method takes to execute You must call <a class="el" href="class_buffered_output.html#af25a2ef199c9f2a3c3c7f1aac9027eb5">nextByteOut()</a> each loop() in order to release the buffered chars. </p>

</div>
</div>
<a id="ab063ee4a76eca24bacae35f7c9ad3828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab063ee4a76eca24bacae35f7c9ad3828">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BufferedOutput::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e4e9f49544294c1fae95038aea2f00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4e9f49544294c1fae95038aea2f00c">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedOutput::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af25a2ef199c9f2a3c3c7f1aac9027eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25a2ef199c9f2a3c3c7f1aac9027eb5">&#9670;&nbsp;</a></span>nextByteOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedOutput::nextByteOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab03bf2140a790975b905007b628bb6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03bf2140a790975b905007b628bb6fe">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BufferedOutput::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3262fc544642f3f42e4f60b887ec1836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3262fc544642f3f42e4f60b887ec1836">&#9670;&nbsp;</a></span>protect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedOutput::protect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d183e5d4084676849bbe5df70184774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d183e5d4084676849bbe5df70184774">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BufferedOutput::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14278ab80fbfd64e6f463e1dc957ae5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14278ab80fbfd64e6f463e1dc957ae5f">&#9670;&nbsp;</a></span>terminateLastLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedOutput::terminateLastLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0bd4dcb4b18cda23c5d88c200d334f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd4dcb4b18cda23c5d88c200d334f7">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedOutput::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf88bb274d39b752e388efc2c139257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf88bb274d39b752e388efc2c139257">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedOutput::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_buffered_output.html">BufferedOutput</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
